import { NextApiRequest, NextApiResponse } from "next";
import { getServerSession } from "next-auth/next";
import { authOptions } from "../auth/[...nextauth]";
import { prisma } from "../../../lib/prisma";

// Type definitions (will be auto-generated by Prisma)
type SubmissionType =
  | "FULL_EXPERIENCE"
  | "ACCOMMODATION"
  | "COURSE_EXCHANGE"
  | "QUICK_TIP"
  | "DESTINATION_INFO";
type SubmissionStatus =
  | "DRAFT"
  | "PENDING"
  | "APPROVED"
  | "REJECTED"
  | "REVISION_NEEDED"
  | "ARCHIVED";

/**
 * Unified Submissions API
 *
 * GET    /api/submissions - List user's submissions (requires auth)
 * POST   /api/submissions - Create new submission (requires auth)
 */

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  const session = await getServerSession(req, res, authOptions);

  if (!session?.user?.email) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  try {
    if (req.method === "GET") {
      return await handleGet(req, res, session.user.email);
    } else if (req.method === "POST") {
      return await handlePost(req, res, session.user.email);
    } else {
      res.setHeader("Allow", ["GET", "POST"]);
      return res
        .status(405)
        .json({ error: `Method ${req.method} not allowed` });
    }
  } catch (error) {
    console.error("Submissions API Error:", error);
    return res.status(500).json({
      error: "Internal server error",
      details: error instanceof Error ? error.message : "Unknown error",
    });
  }
}

async function handleGet(
  req: NextApiRequest,
  res: NextApiResponse,
  userEmail: string,
) {
  const { status, type, limit = "50", offset = "0" } = req.query;

  // Get user
  const user = await prisma.users.findUnique({
    where: { email: userEmail },
  });

  if (!user) {
    return res.status(404).json({ error: "User not found" });
  }

  // Build where clause
  const where: any = {
    userId: user.id,
  };

  if (status && typeof status === "string") {
    where.status = status as SubmissionStatus;
  }

  if (type && typeof type === "string") {
    where.submissionType = type as SubmissionType;
  }

  // Fetch submissions
  const submissions = await prisma.student_submissions.findMany({
    where,
    orderBy: { updatedAt: "desc" },
    take: parseInt(limit as string),
    skip: parseInt(offset as string),
    include: {
      author: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
        },
      },
      reviewer: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  });

  // Get total count
  const total = await prisma.student_submissions.count({ where });

  return res.status(200).json({
    submissions,
    pagination: {
      total,
      limit: parseInt(limit as string),
      offset: parseInt(offset as string),
      hasMore: total > parseInt(offset as string) + parseInt(limit as string),
    },
  });
}

async function handlePost(
  req: NextApiRequest,
  res: NextApiResponse,
  userEmail: string,
) {
  const {
    submissionType,
    data,
    title,
    hostCity,
    hostCountry,
    hostUniversity,
    semester,
    academicYear,
    formStep,
    status = "DRAFT",
  } = req.body;

  // Validate required fields
  if (!submissionType) {
    return res.status(400).json({ error: "submissionType is required" });
  }

  if (!data || typeof data !== "object") {
    return res.status(400).json({ error: "data must be an object" });
  }

  // Validate submission type
  const validTypes: SubmissionType[] = [
    "FULL_EXPERIENCE",
    "ACCOMMODATION",
    "COURSE_EXCHANGE",
    "QUICK_TIP",
    "DESTINATION_INFO",
  ];

  if (!validTypes.includes(submissionType)) {
    return res.status(400).json({
      error: "Invalid submissionType",
      validTypes,
    });
  }

  // Get user
  const user = await prisma.users.findUnique({
    where: { email: userEmail },
  });

  if (!user) {
    return res.status(404).json({ error: "User not found" });
  }

  // Create submission
  const submission = await prisma.student_submissions.create({
    data: {
      userId: user.id,
      submissionType: submissionType as SubmissionType,
      data,
      title: title || null,
      hostCity: hostCity || null,
      hostCountry: hostCountry || null,
      hostUniversity: hostUniversity || null,
      semester: semester || null,
      academicYear: academicYear || null,
      formStep: formStep || null,
      status: status as SubmissionStatus,
      tags: [],
    },
    include: {
      author: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
        },
      },
    },
  });

  return res.status(201).json(submission);
}
